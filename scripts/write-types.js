#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const HEADER = '// AUTO-GENERATED. DO NOT EDIT. Generated by src-tauri/bin/export-types + scripts/write-types.js';
const outputDir = path.join(__dirname, '../frontend/src/lib/backend');
const legacyOutputPath = path.join(__dirname, '../frontend/src/lib/backend.ts');

// Read from stdin
let rawInput = '';
process.stdin.on('data', (chunk) => {
  rawInput += chunk;
});

process.stdin.on('end', () => {
  try {
    // Clean up malformed escape sequences that ts-rs sometimes generates
    rawInput = rawInput.replace(/\\n/g, '\n');

    // ts-rs may emit local `import type` statements when targeting per-type files.
    // These are invalid in bundled output — remove them.
    rawInput = rawInput.replace(/^import type .* from "\.\/.*";\r?\n/gm, '');

    // Check if input contains domain markers
    if (rawInput.includes('// @domain:')) {
      writeDomainSplitFiles(rawInput);
    } else {
      // Fallback: legacy monolithic output (backward compatibility)
      writeLegacyMonolithicFile(rawInput);
    }
  } catch (error) {
    console.error('Failed to write TypeScript definitions:', error.message);
    process.exit(1);
  }
});

process.stdin.on('error', (error) => {
  console.error('Error reading from stdin:', error.message);
  process.exit(1);
});

/**
 * Split input by // @domain:<name> markers and return a map of domain -> content.
 * Multiple sections with the same domain name are merged.
 */
function splitByDomainMarkers(input) {
  const domains = {};
  const lines = input.split('\n');
  let currentDomain = 'common'; // default if no marker precedes content

  for (const line of lines) {
    const match = line.match(/^\/\/ @domain:(\w+)/);
    if (match) {
      currentDomain = match[1];
      if (!domains[currentDomain]) domains[currentDomain] = '';
      continue;
    }
    if (!domains[currentDomain]) domains[currentDomain] = '';
    domains[currentDomain] += line + '\n';
  }

  // Trim trailing whitespace from each domain
  for (const key of Object.keys(domains)) {
    domains[key] = domains[key].trimEnd() + '\n';
  }

  return domains;
}

/**
 * Extract all exported type/interface names from content.
 */
function extractTypeNames(content) {
  const names = new Set();
  const matches = content.matchAll(/export\s+(?:type|interface)\s+(\w+)/g);
  for (const match of matches) {
    names.add(match[1]);
  }
  return names;
}

/**
 * For a given domain's content, find references to types defined in other domains.
 * Returns: { otherDomain: [typeName1, typeName2, ...] }
 */
function findCrossDomainImports(content, ownTypes, typeToDomain, ownDomain) {
  const imports = {};

  // Scan the full content for type references (not just definition bodies),
  // since ts-rs may generate multi-line type definitions with embedded JSDoc.
  // We skip import/export declaration lines to avoid self-referencing.
  const allTypeNames = Object.keys(typeToDomain);
  for (const typeName of allTypeNames) {
    if (ownTypes.has(typeName)) continue;
    const targetDomain = typeToDomain[typeName];
    if (targetDomain === ownDomain) continue;

    // Word-boundary match to avoid substring false positives
    const regex = new RegExp('\\b' + typeName + '\\b');
    if (regex.test(content)) {
      if (!imports[targetDomain]) imports[targetDomain] = [];
      imports[targetDomain].push(typeName);
    }
  }

  return imports;
}

/**
 * Write domain-split files under frontend/src/lib/backend/
 */
function writeDomainSplitFiles(input) {
  const domains = splitByDomainMarkers(input);

  // First pass: collect type names per domain
  const typesByDomain = {};
  for (const [domain, content] of Object.entries(domains)) {
    typesByDomain[domain] = extractTypeNames(content);
  }

  // Deduplicate: if a type appears in multiple domains, keep only the LAST occurrence
  // (later domain markers override earlier ones, which handles intentional reassignment)
  const typeToDomain = {};
  for (const [domain, types] of Object.entries(typesByDomain)) {
    for (const typeName of types) {
      typeToDomain[typeName] = domain;
    }
  }

  // Remove duplicate type definitions from domains where the type is NOT the canonical owner
  for (const [domain, types] of Object.entries(typesByDomain)) {
    for (const typeName of types) {
      if (typeToDomain[typeName] !== domain) {
        // Remove the duplicate export line from this domain's content
        domains[domain] = removeDuplicateExport(domains[domain], typeName);
        types.delete(typeName);
      }
    }
  }

  // Validate critical exports across all domains
  const allContent = Object.values(domains).join('\n');
  validateRequiredExports(allContent);

  // Ensure output directory exists
  fs.mkdirSync(outputDir, { recursive: true });

  const domainNames = Object.keys(domains).sort();

  // Write each domain file
  for (const [domain, content] of Object.entries(domains)) {
    const imports = findCrossDomainImports(content, typesByDomain[domain], typeToDomain, domain);

    let fileContent = HEADER + '\n\n';

    // Add cross-domain import statements
    const importDomains = Object.keys(imports).sort();
    for (const importDomain of importDomains) {
      const importTypes = imports[importDomain].sort().join(', ');
      fileContent += `import type { ${importTypes} } from './${importDomain}';\n`;
    }
    if (importDomains.length > 0) fileContent += '\n';

    fileContent += content;

    writeFileWithRetry(path.join(outputDir, `${domain}.ts`), fileContent);
  }

  // Write index.ts barrel that re-exports from all domain files
  let indexContent = HEADER + '\n\n';
  for (const domain of domainNames) {
    indexContent += `export * from './${domain}';\n`;
  }
  writeFileWithRetry(path.join(outputDir, 'index.ts'), indexContent);

  // Write legacy backward-compatible stub
  const stubContent = HEADER + '\n\nexport * from \'./backend/index\';\n';
  writeFileWithRetry(legacyOutputPath, stubContent);

  console.log(`✅ Generated ${domainNames.length} domain files: ${domainNames.join(', ')}`);
  console.log(`✅ Generated barrel: frontend/src/lib/backend/index.ts`);
  console.log(`✅ Generated legacy stub: frontend/src/lib/backend.ts`);
}

/**
 * Legacy monolithic file writer (backward compatibility if no domain markers present).
 */
function writeLegacyMonolithicFile(typeDefinitions) {
  validateRequiredExports(typeDefinitions);
  writeFileWithRetry(legacyOutputPath, typeDefinitions);
  console.log(`✅ Successfully exported Rust types to TypeScript at ${legacyOutputPath}`);
}

/**
 * Validate that critical type exports are present.
 */
function validateRequiredExports(content) {
  const requiredExports = ['TaskStatus', 'TaskPriority', 'UserAccount'];
  const missingExports = requiredExports.filter(
    (exp) => !content.includes(`export type ${exp}`) && !content.includes(`export interface ${exp}`)
  );

  if (missingExports.length > 0) {
    console.error(`❌ Missing exports: ${missingExports.join(', ')}`);
    console.error('This may cause TypeScript compilation errors. Please check the Rust type generation.');
    process.exit(1);
  }
  console.log(`✅ Validated exports: ${requiredExports.join(', ')}`);
}

/**
 * Remove a duplicate type export from content.
 * Removes the export line and any preceding ts-rs comment/JSDoc blocks.
 */
function removeDuplicateExport(content, typeName) {
  const lines = content.split('\n');
  const result = [];
  let i = 0;

  while (i < lines.length) {
    // Check if this line exports the duplicate type
    const exportRegex = new RegExp(`^export\\s+(?:type|interface)\\s+${typeName}\\b`);
    if (exportRegex.test(lines[i].trim())) {
      // Remove this line, and any preceding ts-rs/JSDoc comment block
      while (result.length > 0) {
        const last = result[result.length - 1].trim();
        if (last.startsWith('//') || last.startsWith('/**') || last.startsWith(' *') || last === '') {
          result.pop();
        } else {
          break;
        }
      }
      i++;
      continue;
    }
    result.push(lines[i]);
    i++;
  }

  return result.join('\n');
}

/**
 * Write file with retry logic for file access issues.
 */
function writeFileWithRetry(filePath, content) {
  let attempts = 0;
  const maxAttempts = 10;

  const tryWrite = () => {
    try {
      fs.writeFileSync(filePath, content, 'utf8');
    } catch (error) {
      attempts++;
      if ((error.code === 'EPERM' || error.code === 'EACCES') && attempts < maxAttempts) {
        console.log(`⚠️  File access denied for ${filePath} (attempt ${attempts}/${maxAttempts}), retrying in 200ms...`);
        const { execSync: sleepSync } = require('child_process');
        try { sleepSync('sleep 0.2'); } catch { /* ignore */ }
        tryWrite();
        return;
      }
      throw error;
    }
  };

  tryWrite();
}
