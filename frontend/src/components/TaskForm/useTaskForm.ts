"use client";

import { useState, useCallback, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { toast } from 'sonner';
import { TaskFormData, FormStep } from './types';
// Legacy service imports removed - now using API routes
import { createLogger } from '@/lib/logger';
import {
  ValidationResult,
  validateRequired,
  validateLength,
  validateEmail,
  validatePhone,
  validateFutureDate,
  validateDateRange,
  validateYear,
  createValidationResult
} from '@/lib/utils/validation-utils';

const logger = createLogger('useTaskForm');

export const useTaskForm = (userId?: string, initialData?: Partial<TaskFormData>) => {
  const getDraftStorageKey = useCallback(() => `task-form-draft:${userId || 'anonymous'}`, [userId]);

  const loadDraftFromStorage = useCallback(() => {
    if (typeof window === 'undefined') return null;
    try {
      const raw = window.localStorage.getItem(getDraftStorageKey());
      if (!raw) return null;
      return JSON.parse(raw) as { data: Partial<TaskFormData>; lastSaved?: string };
    } catch (error) {
      logger.warn('Failed to load task draft from storage', error);
      return null;
    }
  }, [getDraftStorageKey]);

  const saveDraftToStorage = useCallback((data: TaskFormData, lastSaved: string) => {
    if (typeof window === 'undefined') return;
    try {
      const payload = { data, lastSaved };
      window.localStorage.setItem(getDraftStorageKey(), JSON.stringify(payload));
    } catch (error) {
      logger.warn('Failed to save task draft to storage', error);
    }
  }, [getDraftStorageKey]);

  const clearDraftFromStorage = useCallback(() => {
    if (typeof window === 'undefined') return;
    try {
      window.localStorage.removeItem(getDraftStorageKey());
    } catch (error) {
      logger.warn('Failed to clear task draft from storage', error);
    }
  }, [getDraftStorageKey]);

  const [formData, setFormData] = useState<TaskFormData>(() => ({
    // Core fields
    task_number: '',
    title: '', // Will be generated based on form data
    status: 'draft',
    created_by: userId || '',
    creator_id: userId || '',
    
    // Vehicle information
    vehicle_make: '',
    vehicle_model: '',
    vehicle_year: '',
    vehicle_plate: '',
    vehicle_vin: '',
    
    // Customer information  
    customer_name: '',
    customer_email: '',
    customer_phone: '',
    customer_address: '',
    client_id: null,
    
    // PPF zones
    ppf_zones: [],
    custom_ppf_zones: [],
    customZones: {},
    
    // Scheduling
    scheduled_date: '',
    scheduled_time: '',
    start_time: '',
    end_time: '',
    
    // Additional fields
    notes: '',
    lot_film: '',
    external_id: '',
    technician_id: null,
    
    // Workflow
    workflow_status: 'not_started',
    is_available: true,
    
    // Timestamps
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    
    ...initialData
  }));
  
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [taskNumber, setTaskNumber] = useState('');
  const [isDirty, setIsDirty] = useState(false);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);

  // Generate task number placeholder (backend will generate actual number)
  const generateTaskTitle = useCallback(async () => {
    logger.info('Task number will be generated by backend');

    // Don't generate client-side, let backend handle it
    const placeholderNumber = '';
    setTaskNumber(placeholderNumber);
    setFormData(prev => ({
      ...prev,
      task_number: null, // Let backend generate
      title: '', // Will be generated based on form data before submission
      updated_at: new Date().toISOString()
    }));
    setIsDirty(true);

    return placeholderNumber;
  }, []);

  // Generate task number on mount (only for new tasks)
  useEffect(() => {
    if (!initialData?.id && !taskNumber) {
      const initTaskNumber = async () => {
        await generateTaskTitle();
      };
      initTaskNumber();
    } else if (initialData?.task_number) {
      setTaskNumber(initialData.task_number);
    }
  }, [generateTaskTitle, initialData, taskNumber]);

  // Load local draft for new tasks only
  useEffect(() => {
    if (initialData && Object.keys(initialData).length > 0) return;
    const draft = loadDraftFromStorage();
    if (!draft?.data) return;

    setFormData(prev => ({
      ...prev,
      ...draft.data,
      updated_at: new Date().toISOString()
    }));
    setIsDirty(false);
    setLastSaved(draft.lastSaved ? new Date(draft.lastSaved) : null);
  }, [initialData, loadDraftFromStorage]);

  const updateFormData = useCallback((updates: Partial<TaskFormData>) => {
    setFormData(prev => {
      const newData = {
        ...prev,
        ...updates,
        updated_at: new Date().toISOString()
      };
      
      setIsDirty(true);
      return newData;
    });
  }, []);

  const addCustomZone = useCallback((zoneText: string) => {
    if (!zoneText.trim()) return;
    
    // Check if zone already exists (case insensitive)
    const existingZones = [...(formData.ppf_zones || []), ...(formData.custom_ppf_zones || [])];
    const zoneExists = existingZones.some(zone => zone.toLowerCase() === zoneText.toLowerCase());
      
    if (zoneExists) {
      toast.error('Cette zone a déjà été ajoutée');
      return;
    }
    
    // Limit the number of custom zones
    if ((formData.custom_ppf_zones?.length || 0) >= 10) {
      toast.error('Vous ne pouvez pas ajouter plus de 10 zones personnalisées');
      return;
    }
    
    const newZone = zoneText.trim();
    const customId = `custom_${uuidv4()}`;
    
    updateFormData({
      custom_ppf_zones: [...(formData.custom_ppf_zones || []), newZone],
      ppf_zones: [...(formData.ppf_zones || []), customId],
      customZones: {
        ...formData.customZones,
        [customId]: newZone
      }
    });
    
    toast.success('Zone personnalisée ajoutée');
  }, [formData.ppf_zones, formData.custom_ppf_zones, formData.customZones, updateFormData]);

  const removeCustomZone = useCallback((zoneText: string) => {
    // Find the custom ID for this zone text
    const customId = Object.entries(formData.customZones || {})
      .find(([, text]) => text === zoneText)?.[0];
    
    if (!customId) return;
    
    const newCustomZones = { ...formData.customZones };
    delete newCustomZones[customId];
    
    updateFormData({
      custom_ppf_zones: (formData.custom_ppf_zones || []).filter(zone => zone !== zoneText),
      ppf_zones: (formData.ppf_zones || []).filter(zone => zone !== customId),
      customZones: newCustomZones
    });
    
    toast.success('Zone personnalisée supprimée');
  }, [formData.custom_ppf_zones, formData.ppf_zones, formData.customZones, updateFormData]);

  const validateStep = useCallback((step: FormStep): ValidationResult => {
    const errors: Record<string, string> = {};

    if (step === 'vehicle') {
      // Vehicle make validation
      const makeError = validateRequired(formData.vehicle_make || '', 'Make');
      if (makeError) {
        errors.vehicle_make = makeError;
      } else {
        const lengthError = validateLength(formData.vehicle_make, 'Make', 2);
        if (lengthError) errors.vehicle_make = lengthError;
      }

      // Vehicle model validation
      const modelError = validateRequired(formData.vehicle_model || '', 'Model');
      if (modelError) {
        errors.vehicle_model = modelError;
      } else {
        const lengthError = validateLength(formData.vehicle_model, 'Model', 1);
        if (lengthError) errors.vehicle_model = lengthError;
      }

      // Vehicle year validation
      const yearError = validateYear(formData.vehicle_year, "Year");
      if (yearError) errors.vehicle_year = yearError;

      // Vehicle plate validation
      const plateError = validateRequired(formData.vehicle_plate || '', 'License plate');
      if (plateError) {
        errors.vehicle_plate = plateError;
      } else {
        const lengthError = validateLength(formData.vehicle_plate, 'License plate', 4);
        if (lengthError) errors.vehicle_plate = lengthError;
      }

      // Optional VIN validation
      if (formData.vehicle_vin && formData.vehicle_vin.length !== 17) {
        errors.vehicle_vin = 'VIN must contain exactly 17 characters';
      }
    }

    if (step === 'customer') {
      // Customer information is optional but validate format if provided
      const emailError = validateEmail(formData.customer_email || '');
      if (emailError) errors.customer_email = emailError;

      const phoneError = validatePhone(formData.customer_phone || '');
      if (phoneError) errors.customer_phone = phoneError;
    }

    if (step === 'ppf') {
      const totalZones = (formData.ppf_zones?.length || 0) + (formData.custom_ppf_zones?.length || 0);
      if (totalZones === 0) {
        errors.ppf_zones = 'Please select at least one PPF zone';
      } else if (totalZones > 20) {
        errors.ppf_zones = 'You cannot select more than 20 zones';
      }
    }

    if (step === 'schedule') {
      // Date validation
      const dateError = validateRequired(formData.scheduled_date || '', 'Date');
      if (dateError) {
        errors.scheduled_date = dateError;
      } else {
        const futureError = validateFutureDate(formData.scheduled_date, 'Date');
        if (futureError) errors.scheduled_date = futureError;

        const rangeError = validateDateRange(formData.scheduled_date, 'Date', 1);
        if (rangeError) errors.scheduled_date = rangeError;
      }

      // Time validation
      const timeError = validateRequired(formData.scheduled_time || '', "Time");
      if (timeError) {
        errors.scheduled_time = timeError;
      } else {
        const [hours, minutes] = formData.scheduled_time.split(':').map(Number);
        if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
          errors.scheduled_time = 'Invalid time format';
        }

        // If same day, check time is not in the past
        if (formData.scheduled_date === new Date().toISOString().split('T')[0]) {
          const selectedDateTime = new Date(formData.scheduled_date);
          selectedDateTime.setHours(hours, minutes, 0, 0);

          const now = new Date();
          if (selectedDateTime < now) {
            errors.scheduled_time = "Time cannot be in the past";
          }
        }
      }

      // Validate start and end times if provided
      if (formData.start_time && formData.end_time) {
        const startTime = new Date(`1970-01-01T${formData.start_time}:00`);
        const endTime = new Date(`1970-01-01T${formData.end_time}:00`);

        if (endTime <= startTime) {
          errors.end_time = "End time must be after start time";
        }
      }

      // Validate notes length
      if (formData.notes && formData.notes.length > 1000) {
        errors.notes = 'Notes must not exceed 1000 characters';
      }
    }

    return createValidationResult(Object.keys(errors).length === 0, errors);
  }, [formData]);

  const canProceedToNextStep = useCallback((step: FormStep) => {
    const { isValid } = validateStep(step);
    return isValid;
  }, [validateStep]);

  const autoSave = useCallback(async () => {
    if (!isDirty || loading) return;
    
    try {
      setLoading(true);
      const now = new Date();
      saveDraftToStorage(
        {
          ...formData,
          updated_at: now.toISOString()
        },
        now.toISOString()
      );
      setIsDirty(false);
      setLastSaved(now);
      logger.info('Auto-save completed');
    } catch (error) {
      logger.error('Auto-save failed:', error);
    } finally {
      setLoading(false);
    }
  }, [formData, isDirty, loading, saveDraftToStorage, setLoading]);



  return {
    formData,
    updateFormData,
    loading,
    setLoading,
    error,
    setError,
    taskNumber,
    addCustomZone,
    removeCustomZone,
    validateStep,
    canProceedToNextStep,
    isDirty,
    lastSaved,
    autoSave,
    clearDraft: clearDraftFromStorage,
  };
};
