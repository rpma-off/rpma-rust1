'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import type {
  PPFInterventionData,
  PPFInterventionStep,
  StartInterventionDTO,
  AdvanceStepDTO,
  FinalizeInterventionDTO,
  InterventionCreationResponse,
  StepProgressResponse,
  InterventionFinalizationResponse
} from '@/lib/types/ppf-intervention';
// Client-side hook - uses API calls instead of direct service imports

interface UseInterventionWorkflowProps {
  taskId?: string;
  autoSave?: boolean;
  autoSaveInterval?: number;
  onInterventionChange?: (intervention: PPFInterventionData) => void;
  onStepChange?: (step: PPFInterventionStep) => void;
  onError?: (error: string) => void;
}

interface UseInterventionWorkflowReturn {
  // State
  intervention: PPFInterventionData | null;
  currentStep: PPFInterventionStep | null;
  allSteps: PPFInterventionStep[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  createIntervention: (data: StartInterventionDTO) => Promise<InterventionCreationResponse>;
  advanceStep: (data: AdvanceStepDTO) => Promise<StepProgressResponse>;
  finalizeIntervention: (data: FinalizeInterventionDTO) => Promise<InterventionFinalizationResponse>;
  pauseStep: () => Promise<void>;
  resumeStep: () => Promise<void>;
  
  // Navigation
  getCurrentStep: () => PPFInterventionStep | null;
  getStepByNumber: (stepNumber: number) => PPFInterventionStep | null;
  canNavigateToStep: (step: PPFInterventionStep) => boolean;
  navigateToStep: (step: PPFInterventionStep) => boolean;
  
  // Validation
  validateCurrentStep: () => Promise<{ isValid: boolean; errors: string[] }>;
  validateStep: () => Promise<{ isValid: boolean; errors: string[] }>; // Alias for backward compatibility
  
  // Utilities
  getProgress: () => { current: number; total: number; percentage: number };
  getTimeElapsed: () => { step: number; total: number };
  clearError: () => void;
  reset: () => void;
  
  // Service-powered methods
  loadIntervention: (interventionId: string) => Promise<void>;
  loadActiveIntervention: (technicianId?: string) => Promise<void>;
}

export function useInterventionWorkflow({
  taskId,
  autoSave = true,
  autoSaveInterval = 30000, // 30 seconds
  onInterventionChange,
  onStepChange,
  onError
}: UseInterventionWorkflowProps = {}): UseInterventionWorkflowReturn {
  
  // State
  const [intervention, setIntervention] = useState<PPFInterventionData | null>(null);
  const [currentStep, setCurrentStep] = useState<PPFInterventionStep | null>(null);
  const [allSteps, setAllSteps] = useState<PPFInterventionStep[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Refs for auto-save
  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastSaveRef = useRef<Date | null>(null);

  // Auto-save logic
  const scheduleAutoSave = useCallback(() => {
    if (!autoSave || !intervention) return;

    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }

    autoSaveTimeoutRef.current = setTimeout(() => {
      // Auto-save implementation would go here
      console.log('Auto-saving intervention data...');
      lastSaveRef.current = new Date();
    }, autoSaveInterval);
  }, [autoSave, autoSaveInterval, intervention]);

  // Cleanup auto-save timeout
  useEffect(() => {
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, []);

  // Trigger callbacks when state changes
  useEffect(() => {
    if (intervention) {
      onInterventionChange?.(intervention);
      scheduleAutoSave();
    }
  }, [intervention, onInterventionChange, scheduleAutoSave]);

  useEffect(() => {
    if (currentStep) {
      onStepChange?.(currentStep);
    }
  }, [currentStep, onStepChange]);

  // Error handling
  const handleError = useCallback((errorMessage: string, originalError?: any) => {
    console.error('Intervention workflow error:', errorMessage, originalError);
    setError(errorMessage);
    onError?.(errorMessage);
  }, [onError]);

  // Create intervention using API
  const createIntervention = useCallback(async (data: StartInterventionDTO): Promise<InterventionCreationResponse> => {
    try {
      setIsLoading(true);
      setError(null);

      // Use API instead of direct service
      const response = await fetch('/api/ppf/interventions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
      }
      
      const result = await response.json();
      
      // Handle API response

      setIntervention(result.intervention);
      setAllSteps(result.steps);
      if (result.steps && result.steps.length > 0) {
        // First active step
        const firstActive = result.steps.find(s => s.status === 'in_progress') || result.steps[0];
        setCurrentStep(firstActive);
      }

      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create intervention';
      handleError(errorMessage, err);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [handleError]);

  // Advance step using API
  const advanceStep = useCallback(async (data: AdvanceStepDTO): Promise<StepProgressResponse> => {
    try {
      setIsLoading(true);
      setError(null);

      // Use API instead of direct service
      const response = await fetch('/api/ppf/interventions/advance-step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
      }
      
      const result = await response.json();

      // Update local state from API response
      setAllSteps(prev => prev.map(step => step.id === result.updated_step.id ? result.updated_step : step));
      if (result.next_step) {
        setCurrentStep(result.next_step);
      }
      setIntervention(prev => prev ? {
        ...prev,
        current_step: result.intervention_progress.current_step,
        progress_percentage: result.intervention_progress.progress_percentage,
        updated_at: new Date().toISOString(),
      } : prev);

      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to advance step';
      handleError(errorMessage, err);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [handleError]);

  // Finalize intervention using API
  const finalizeIntervention = useCallback(async (data: FinalizeInterventionDTO): Promise<InterventionFinalizationResponse> => {
    try {
      setIsLoading(true);
      setError(null);

      // Use API instead of direct service
      const response = await fetch('/api/ppf/interventions/finalize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
      }
      
      const result = await response.json();

      setIntervention(result.intervention);

      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to finalize intervention';
      handleError(errorMessage, err);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [handleError]);

  // Pause step
  const pauseStep = useCallback(async () => {
    if (!currentStep || currentStep.status !== 'in_progress') return;

    try {
      const updatedStep: PPFInterventionStep = {
        ...currentStep,
        status: 'paused',
        paused_at: new Date().toISOString()
      };

      setCurrentStep(updatedStep);
      setAllSteps(prev => prev.map(step => 
        step.id === updatedStep.id ? updatedStep : step
      ));
    } catch (err) {
      handleError('Failed to pause step', err);
    }
  }, [currentStep, handleError]);

  // Resume step
  const resumeStep = useCallback(async () => {
    if (!currentStep || currentStep.status !== 'paused') return;

    try {
      const updatedStep: PPFInterventionStep = {
        ...currentStep,
        status: 'in_progress',
        paused_at: undefined
      };

      setCurrentStep(updatedStep);
      setAllSteps(prev => prev.map(step => 
        step.id === updatedStep.id ? updatedStep : step
      ));
    } catch (err) {
      handleError('Failed to resume step', err);
    }
  }, [currentStep, handleError]);

  // Navigation helpers
  const getCurrentStep = useCallback(() => currentStep, [currentStep]);

  const getStepByNumber = useCallback((stepNumber: number) => {
    return allSteps.find(step => step.step_number === stepNumber) || null;
  }, [allSteps]);

  const canNavigateToStep = useCallback((step: PPFInterventionStep) => {
    return step.status === 'completed' || step.id === currentStep?.id;
  }, [currentStep]);

  const navigateToStep = useCallback((step: PPFInterventionStep) => {
    if (canNavigateToStep(step)) {
      setCurrentStep(step);
      return true;
    }
    return false;
  }, [canNavigateToStep]);

  // Validation
  const validateCurrentStep = useCallback(async () => {
    if (!currentStep) {
      return { isValid: false, errors: ['No current step'] };
    }

    // Step-specific validation would go here
    const errors: string[] = [];

    if (currentStep.requires_photos && currentStep.photos.length < currentStep.min_photos_required) {
      errors.push(`At least ${currentStep.min_photos_required} photos required`);
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }, [currentStep]);

  // Utility functions
  const getProgress = useCallback(() => {
    const completed = allSteps.filter(step => step.status === 'completed').length;
    const total = allSteps.length;
    return {
      current: completed,
      total,
      percentage: total > 0 ? Math.round((completed / total) * 100) : 0
    };
  }, [allSteps]);

  const getTimeElapsed = useCallback(() => {
    const now = new Date();
    
    const stepElapsed = currentStep?.started_at ? 
      Math.floor((now.getTime() - new Date(currentStep.started_at).getTime()) / (1000 * 60)) : 0;
    
    const totalElapsed = intervention?.actual_start ? 
      Math.floor((now.getTime() - new Date(intervention.actual_start).getTime()) / (1000 * 60)) : 0;

    return {
      step: stepElapsed,
      total: totalElapsed
    };
  }, [currentStep, intervention]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const reset = useCallback(() => {
    setIntervention(null);
    setCurrentStep(null);
    setAllSteps([]);
    setError(null);
    setIsLoading(false);
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }
  }, []);

  // Load intervention by ID using API
  const loadIntervention = useCallback(async (interventionId: string) => {
    try {
      setIsLoading(true);
      setError(null);

      // Load intervention data via API
      const [interventionResponse, stepsResponse] = await Promise.all([
        fetch(`/api/ppf/interventions/${interventionId}`),
        fetch(`/api/ppf/interventions/${interventionId}/steps`)
      ]);

      if (!interventionResponse.ok || !stepsResponse.ok) {
        throw new Error('Failed to load intervention data');
      }

      const intervention = await interventionResponse.json();
      const steps = await stepsResponse.json();

      setIntervention(intervention);
      setAllSteps(steps);
      
      // Set current step based on intervention status
      const currentStep = steps.find(s => s.status === 'in_progress') || 
                          steps.find(s => s.step_number === intervention.current_step) || 
                          null;
      setCurrentStep(currentStep);

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load intervention';
      handleError(errorMessage, err);
    } finally {
      setIsLoading(false);
    }
  }, [handleError]);

  // Load active intervention for current user
  const loadActiveIntervention = useCallback(async (technicianId?: string) => {
    try {
      setIsLoading(true);
      setError(null);

      if (!technicianId) {
        // If no technician ID provided, use current user endpoint
        const response = await fetch('/api/ppf/interventions/active');
        if (!response.ok) {
          throw new Error('Failed to load active intervention');
        }
        const result = await response.json();
        
        if (result && result.id) {
          await loadIntervention(result.id);
        } else {
          reset();
        }
        return;
      }

      const response = await fetch(`/api/ppf/interventions/active?technicianId=${technicianId}`);
      if (!response.ok) {
        throw new Error('Failed to load active intervention');
      }
      
      const result = await response.json();
      
      if (result && result.id) {
        // Load the full intervention with steps
        await loadIntervention(result.id);
      } else {
        // No active intervention
        reset();
      }

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load active intervention';
      handleError(errorMessage, err);
    } finally {
      setIsLoading(false);
    }
  }, [interventionService, handleError, loadIntervention, reset]);

  return {
    // State
    intervention,
    currentStep,
    allSteps,
    isLoading,
    error,
    
    // Actions
    createIntervention,
    advanceStep,
    finalizeIntervention,
    pauseStep,
    resumeStep,
    
    // Navigation
    getCurrentStep,
    getStepByNumber,
    canNavigateToStep,
    navigateToStep,
    
    // Validation
    validateCurrentStep,
    validateStep: validateCurrentStep, // Alias for backward compatibility
    
    // Utilities
    getProgress,
    getTimeElapsed,
    clearError,
    reset,
    
    // Service-powered methods
    loadIntervention,
    loadActiveIntervention
  };
}