//! Unit tests for Inventory Transaction Management
//!
//! This module contains comprehensive unit tests for inventory transaction functionality,
//! focusing on stock movements, adjustments, and reporting.

use crate::models::material::{
    InventoryTransaction, InventoryTransactionType, Material, MaterialType, UnitOfMeasure,
};
use crate::services::material::{
    CreateInventoryTransactionRequest, MaterialError, MaterialService,
};
use crate::test_utils::TestDatabase;
use chrono::{DateTime, TimeZone, Utc};

#[cfg(test)]
mod tests {
    use super::*;

    /// Helper function to create a basic material
    fn create_test_material(service: &MaterialService, sku: &str, initial_stock: f64) -> Material {
        let request = crate::services::material::CreateMaterialRequest {
            sku: skuString::from(""),
            name: format!("Test Material {}", sku),
            description: Some("Test material for transactions"String::from("")),
            material_type: MaterialType::PpfFilm,
            category: Some("Films"String::from("")),
            subcategory: None,
            category_id: None,
            brand: Some("TestBrand"String::from("")),
            model: None,
            specifications: None,
            unit_of_measure: UnitOfMeasure::Meter,
            minimum_stock: Some(10.0),
            maximum_stock: Some(1000.0),
            reorder_point: Some(20.0),
            unit_cost: Some(15.50),
            currency: Some("EUR"String::from("")),
            supplier_id: None,
            supplier_name: None,
            supplier_sku: None,
            quality_grade: None,
            certification: None,
            expiry_date: None,
            batch_number: None,
            storage_location: Some("Warehouse A"String::from("")),
            warehouse_id: None,
        };

        let material = service
            .create_material(request, Some("test_user"String::from("")))
            .unwrap();

        if initial_stock > 0.0 {
            let update_request = crate::services::material::UpdateStockRequest {
                material_id: material.id.clone().unwrap(),
                quantity_change: initial_stock,
                reason: "Initial stock"String::from(""),
                recorded_by: Some("test_user"String::from("")),
            };
            service.update_stock(update_request).unwrap();
        }

        material
    }

    #[test]
    fn test_create_stock_in_transaction() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "STOCK-IN-001", 0.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockIn,
            quantity: 100.0,
            reference_number: Some("PO-001"String::from("")),
            reference_type: Some("Purchase Order"String::from("")),
            notes: Some("Initial purchase order"String::from("")),
            unit_cost: Some(15.50),
            warehouse_id: Some("WH-001"String::from("")),
            location_from: None,
            location_to: Some("Rack A-1"String::from("")),
            batch_number: Some("BATCH-001"String::from("")),
            expiry_date: Some(Utc.with_ymd_and_hms(2025, 12, 31, 0, 0, 0).unwrap()),
            quality_status: Some("Good"String::from("")),
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_ok());

        let transaction = result.unwrap();
        assert_eq!(transaction.material_id, material.id.unwrap());
        assert_eq!(
            transaction.transaction_type,
            InventoryTransactionType::StockIn
        );
        assert_eq!(transaction.quantity, 100.0);
        assert_eq!(transaction.reference_number, Some("PO-001"String::from("")));
        assert_eq!(
            transaction.reference_type,
            Some("Purchase Order"String::from(""))
        );
        assert_eq!(transaction.unit_cost, Some(15.50));
        assert_eq!(transaction.warehouse_id, Some("WH-001"String::from("")));
        assert_eq!(transaction.location_to, Some("Rack A-1"String::from("")));
        assert_eq!(transaction.batch_number, Some("BATCH-001"String::from("")));
        assert_eq!(transaction.quality_status, Some("Good"String::from("")));

        // Verify material stock was updated
        let updated_material = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated_material.current_stock, 100.0);
    }

    #[test]
    fn test_create_stock_out_transaction() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "STOCK-OUT-001", 100.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 25.0,
            reference_number: Some("SO-001"String::from("")),
            reference_type: Some("Sales Order"String::from("")),
            notes: Some("Material sold to customer"String::from("")),
            unit_cost: None,
            warehouse_id: Some("WH-001"String::from("")),
            location_from: Some("Rack A-1"String::from("")),
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_ok());

        let transaction = result.unwrap();
        assert_eq!(
            transaction.transaction_type,
            InventoryTransactionType::StockOut
        );
        assert_eq!(transaction.quantity, 25.0);
        assert_eq!(transaction.reference_number, Some("SO-001"String::from("")));
        assert_eq!(transaction.location_from, Some("Rack A-1"String::from("")));

        // Verify material stock was reduced
        let updated_material = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated_material.current_stock, 75.0); // 100 - 25
    }

    #[test]
    fn test_create_adjustment_transaction() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "ADJUST-001", 50.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Adjustment,
            quantity: -5.0, // Negative adjustment (loss)
            reference_number: Some("ADJ-001"String::from("")),
            reference_type: Some("Physical Count"String::from("")),
            notes: Some("Physical count discrepancy"String::from("")),
            unit_cost: None,
            warehouse_id: Some("WH-001"String::from("")),
            location_from: Some("Rack A-1"String::from("")),
            location_to: Some("Rack A-1"String::from("")),
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_ok());

        let transaction = result.unwrap();
        assert_eq!(
            transaction.transaction_type,
            InventoryTransactionType::Adjustment
        );
        assert_eq!(transaction.quantity, -5.0);
        assert_eq!(transaction.reference_number, Some("ADJ-001"String::from("")));
        assert_eq!(
            transaction.reference_type,
            Some("Physical Count"String::from(""))
        );

        // Verify material stock was adjusted
        let updated_material = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated_material.current_stock, 45.0); // 50 - 5
    }

    #[test]
    fn test_create_transfer_transaction() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "TRANSFER-001", 100.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Transfer,
            quantity: 30.0,
            reference_number: Some("TRF-001"String::from("")),
            reference_type: Some("Warehouse Transfer"String::from("")),
            notes: Some("Transfer to warehouse B"String::from("")),
            unit_cost: None,
            warehouse_id: Some("WH-001"String::from("")),
            location_from: Some("WH-001-Rack-A"String::from("")),
            location_to: Some("WH-002-Rack-B"String::from("")),
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_ok());

        let transaction = result.unwrap();
        assert_eq!(
            transaction.transaction_type,
            InventoryTransactionType::Transfer
        );
        assert_eq!(transaction.quantity, 30.0);
        assert_eq!(transaction.reference_number, Some("TRF-001"String::from("")));
        assert_eq!(transaction.location_from, Some("WH-001-Rack-A"String::from("")));
        assert_eq!(transaction.location_to, Some("WH-002-Rack-B"String::from("")));

        // For transfers, stock should remain the same (just location change)
        let updated_material = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated_material.current_stock, 100.0);
    }

    #[test]
    fn test_create_waste_transaction() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "WASTE-001", 75.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Waste,
            quantity: 5.0,
            reference_number: Some("WST-001"String::from("")),
            reference_type: Some("Material Waste"String::from("")),
            notes: Some("Damaged during installation"String::from("")),
            unit_cost: None,
            warehouse_id: Some("WH-001"String::from("")),
            location_from: Some("Rack A-1"String::from("")),
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: Some("Damaged"String::from("")),
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_ok());

        let transaction = result.unwrap();
        assert_eq!(
            transaction.transaction_type,
            InventoryTransactionType::Waste
        );
        assert_eq!(transaction.quantity, 5.0);
        assert_eq!(transaction.reference_number, Some("WST-001"String::from("")));
        assert_eq!(transaction.quality_status, Some("Damaged"String::from("")));

        // Verify material stock was reduced
        let updated_material = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated_material.current_stock, 70.0); // 75 - 5
    }

    #[test]
    fn test_create_consumption_transaction() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "CONSUME-001", 60.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Consumption,
            quantity: 15.0,
            reference_number: Some("INT-001"String::from("")),
            reference_type: Some("Intervention"String::from("")),
            notes: Some("Used in PPF installation"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: Some("BATCH-001"String::from("")),
            expiry_date: None,
            quality_status: None,
            intervention_id: Some("intervention-001"String::from("")),
            step_id: Some("step-001"String::from("")),
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_ok());

        let transaction = result.unwrap();
        assert_eq!(
            transaction.transaction_type,
            InventoryTransactionType::Consumption
        );
        assert_eq!(transaction.quantity, 15.0);
        assert_eq!(
            transaction.intervention_id,
            Some("intervention-001"String::from(""))
        );
        assert_eq!(transaction.step_id, Some("step-001"String::from("")));
        assert_eq!(transaction.batch_number, Some("BATCH-001"String::from("")));

        // Verify material stock was reduced
        let updated_material = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated_material.current_stock, 45.0); // 60 - 15
    }

    #[test]
    fn test_transaction_insufficient_stock_error() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "INSUFF-001", 10.0);

        let request = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 20.0, // More than available
            reference_number: Some("SO-002"String::from("")),
            reference_type: Some("Sales Order"String::from("")),
            notes: Some("Attempt to exceed stock"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_err());

        let error = result.unwrap_err();
        match error {
            MaterialError::InsufficientStock(msg) => {
                assert!(msg.contains("stock"));
            }
            _ => panic!("Expected InsufficientStock error"),
        }
    }

    #[test]
    fn test_transaction_material_not_found() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let request = CreateInventoryTransactionRequest {
            material_id: "non-existent-material"String::from(""),
            transaction_type: InventoryTransactionType::StockIn,
            quantity: 50.0,
            reference_number: Some("PO-003"String::from("")),
            reference_type: Some("Purchase Order"String::from("")),
            notes: Some("Test with non-existent material"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service.create_inventory_transaction(request, Some("test_user"String::from("")));
        assert!(result.is_err());

        let error = result.unwrap_err();
        match error {
            MaterialError::NotFound(msg) => {
                assert!(msg.contains("Material"));
            }
            _ => panic!("Expected NotFound error"),
        }
    }

    #[test]
    fn test_get_transaction_history() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "HISTORY-001", 100.0);

        // Create multiple transactions
        for i in 1..=5 {
            let request = CreateInventoryTransactionRequest {
                material_id: material.id.clone().unwrap(),
                transaction_type: if i % 2 == 0 {
                    InventoryTransactionType::StockOut
                } else {
                    InventoryTransactionType::StockIn
                },
                quantity: 10.0,
                reference_number: Some(format!("TRX-{:03}", i)),
                reference_type: Some("Test Transaction"String::from("")),
                notes: Some(format!("Test transaction {}", i)),
                unit_cost: None,
                warehouse_id: None,
                location_from: None,
                location_to: None,
                batch_number: None,
                expiry_date: None,
                quality_status: None,
                intervention_id: None,
                step_id: None,
            };

            service
                .create_inventory_transaction(request, Some("test_user"String::from("")))
                .unwrap();
        }

        // Get transaction history
        let result = service.get_transaction_history(material.id.unwrap().as_str(), None, None);
        assert!(result.is_ok());

        let history = result.unwrap();
        assert_eq!(history.len(), 5);

        // Verify transactions are ordered by date (newest first)
        assert!(history[0].created_at >= history[1].created_at);
        assert!(history[1].created_at >= history[2].created_at);
    }

    #[test]
    fn test_get_inventory_movement_summary() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "SUMMARY-001", 0.0);

        // Create transactions with different types
        let stock_in = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockIn,
            quantity: 100.0,
            reference_number: Some("PO-SUMMARY"String::from("")),
            reference_type: Some("Purchase Order"String::from("")),
            notes: None,
            unit_cost: Some(15.50),
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(stock_in, Some("test_user"String::from("")))
            .unwrap();

        let stock_out = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 20.0,
            reference_number: Some("SO-SUMMARY"String::from("")),
            reference_type: Some("Sales Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(stock_out, Some("test_user"String::from("")))
            .unwrap();

        let waste = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Waste,
            quantity: 5.0,
            reference_number: Some("WASTE-SUMMARY"String::from("")),
            reference_type: Some("Material Waste"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(waste, Some("test_user"String::from("")))
            .unwrap();

        // Get movement summary
        let result = service.get_inventory_movement_summary(material.id.unwrap().as_str());
        assert!(result.is_ok());

        let summary = result.unwrap();
        assert_eq!(summary.total_in, 100.0);
        assert_eq!(summary.total_out, 25.0); // 20 stock out + 5 waste
        assert_eq!(summary.net_movement, 75.0); // 100 - 25
        assert_eq!(summary.current_stock, 75.0);
    }

    // === TRANSACTION ROLLBACK SCENARIOS ===

    #[test]
    fn test_transaction_rollback_adjustment_to_previous_stock() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "ROLLBACK-001", 100.0);

        // Create a stock out transaction
        let stock_out = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 30.0,
            reference_number: Some("SO-ROLLBACK"String::from("")),
            reference_type: Some("Sales Order"String::from("")),
            notes: Some("Customer order"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(stock_out, Some("test_user"String::from("")))
            .unwrap();

        // Verify stock was reduced
        let updated = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated.current_stock, 70.0);

        // Create an adjustment transaction to restore stock (customer returned)
        let adjustment = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Adjustment,
            quantity: 100.0, // Restore to original
            reference_number: Some("RETURN-ADJ"String::from("")),
            reference_type: Some("Customer Return"String::from("")),
            notes: Some("Customer returned the material"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: Some("Returned"String::from("")),
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(adjustment, Some("test_user"String::from("")))
            .unwrap();

        // Verify stock was restored
        let final_stock = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(final_stock.current_stock, 100.0);
    }

    #[test]
    fn test_transaction_rollback_with_negative_adjustment() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "ROLLBACK-NEGATIVE-001", 50.0);

        // Create a stock in transaction (might have been recorded by mistake)
        let stock_in = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockIn,
            quantity: 25.0,
            reference_number: Some("PO-MISTAKE"String::from("")),
            reference_type: Some("Purchase Order"String::from("")),
            notes: Some("Recorded by mistake"String::from("")),
            unit_cost: Some(10.0),
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(stock_in, Some("test_user"String::from("")))
            .unwrap();

        // Verify stock was increased
        let updated = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(updated.current_stock, 75.0);

        // Create an adjustment to correct the mistake
        let adjustment = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Adjustment,
            quantity: 50.0, // Back to original
            reference_number: Some("CORRECTION-ADJ"String::from("")),
            reference_type: Some("Inventory Correction"String::from("")),
            notes: Some("Correcting previous mistake"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: Some("Corrected"String::from("")),
            intervention_id: None,
            step_id: None,
        };
        service
            .create_inventory_transaction(adjustment, Some("test_user"String::from("")))
            .unwrap();

        // Verify stock was corrected
        let final_stock = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(final_stock.current_stock, 50.0);
    }

    // === CONCURRENT TRANSACTION HANDLING ===

    #[test]
    fn test_concurrent_transactions_same_material() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "CONCURRENT-001", 100.0);

        // Create multiple transactions in sequence (simulating concurrent operations)
        let stock_out1 = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 10.0,
            reference_number: Some("CONCURRENT-1"String::from("")),
            reference_type: Some("Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let stock_out2 = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 15.0,
            reference_number: Some("CONCURRENT-2"String::from("")),
            reference_type: Some("Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let stock_out3 = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 20.0,
            reference_number: Some("CONCURRENT-3"String::from("")),
            reference_type: Some("Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        // Execute transactions sequentially
        service
            .create_inventory_transaction(stock_out1, Some(String::from("test_user")))
            .unwrap();
        
        let material_after_1 = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material_after_1.current_stock, 90.0);

        service
            .create_inventory_transaction(stock_out2, Some("test_user"String::from("")))
            .unwrap();
        
        let material_after_2 = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material_after_2.current_stock, 75.0);

        service
            .create_inventory_transaction(stock_out3, Some("test_user"String::from("")))
            .unwrap();
        
        let material_after_3 = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material_after_3.current_stock, 55.0);
    }

    #[test]
    fn test_concurrent_transactions_insufficient_stock_later() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "CONCURRENT-FAIL-001", 50.0);

        // First transaction should succeed
        let stock_out1 = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 30.0,
            reference_number: Some("CONCURRENT-SUCCESS"String::from("")),
            reference_type: Some("Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        service
            .create_inventory_transaction(stock_out1, Some("test_user".to_string()))
            .unwrap();

        // Second transaction should fail due to insufficient stock
        let stock_out2 = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 30.0, // Only 20 left
            reference_number: Some(String::from("CONCURRENT-FAIL")),
            reference_type: Some(String::from("Order")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service
            .create_inventory_transaction(stock_out2, Some("test_user".to_string"));
        assert!(result.is_err());

        let error = result.unwrap_err();
        match error {
            MaterialError::InsufficientStock(msg) => {
                assert!(msg.contains("Insufficient stock"));
            }
            _ => panic!("Expected InsufficientStock error"),
        }

        // Verify stock wasn't changed by the failed transaction
        let material_after = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material_after.current_stock, 20.0); // Still 20 left from first transaction
    }

    // === TRANSACTION REPORTING ===

    #[test]
    fn test_transaction_reporting_by_date_range() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "REPORTING-001", 0.0);

        // Create transactions at different times
        let yesterday = Utc::now() - chrono::Duration::days(1);
        let today = Utc::now();
        let tomorrow = Utc::now() + chrono::Duration::days(1);

        // This would require modifying the service to accept custom dates
        // For now, we'll just verify transaction history functionality
        let stock_in = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockIn,
            quantity: 50.0,
            reference_number: Some("PO-REPORTING"String::from("")),
            reference_type: Some("Purchase Order"String::from("")),
            notes: Some("Initial stock"String::from("")),
            unit_cost: Some(10.0),
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        service
            .create_inventory_transaction(stock_in, Some("test_user"String::from("")))
            .unwrap();

        let stock_out = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 15.0,
            reference_number: Some("SO-REPORTING"String::from("")),
            reference_type: Some("Sales Order"String::from("")),
            notes: Some("Customer order"String::from("")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
};

        service
            .create_inventory_transaction(stock_out, Some(String::from("test_user")))
            .unwrap();

        // Get transaction history
        let history = service
            .get_transaction_history(material.id.unwrap().as_str(), None, None)
            .unwrap();
        
        assert_eq!(history.len(), 2);
        
        // Verify transactions are ordered by date (newest first)
        assert!(history[0].performed_at >= history[1].performed_at);
        
        // Verify transaction types
        assert_eq!(
            history[0].transaction_type,
            InventoryTransactionType::StockOut
        );
        assert_eq!(
            history[1].transaction_type,
            InventoryTransactionType::StockIn
        );
        
        // Verify quantities
        assert_eq!(history[0].quantity, 15.0);
        assert_eq!(history[1].quantity, 50.0);
    }

    #[test]
    fn test_transaction_reporting_by_type() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "REPORTING-TYPE-001", 0.0);

        // Create different types of transactions
        let stock_in = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockIn,
            quantity: 50.0,
            reference_number: Some(String::from("PO-TYPE")),
            reference_type: Some(String::from("Purchase Order")),
            notes: None,
            unit_cost: Some(10.0),
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        service
            .create_inventory_transaction(stock_in, Some("test_user".to_string"))
            .unwrap();

        let waste = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::Waste,
            quantity: 5.0,
            reference_number: Some(String::from("WASTE-TYPE")),
            reference_type: Some(String::from("Material Waste")),
            notes: Some(String::from("Damaged material")),
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: Some("Damaged"String::from("")),
            intervention_id: None,
            step_id: None,
        };

        service
            .create_inventory_transaction(waste, Some("test_user".to_string"))
            .unwrap();

        // Get history filtered by transaction type
        let stock_in_history = service
            .get_transaction_history(
                material.id.unwrap().as_str(),
                Some(InventoryTransactionType::StockIn),
                None,
            )
            .unwrap();
        
        assert_eq!(stock_in_history.len(), 1);
        assert_eq!(
            stock_in_history[0].transaction_type,
            InventoryTransactionType::StockIn
        );

        let waste_history = service
            .get_transaction_history(
                material.id.unwrap().as_str(),
                Some(InventoryTransactionType::Waste),
                None,
            )
            .unwrap();
        
        assert_eq!(waste_history.len(), 1);
        assert_eq!(
            waste_history[0].transaction_type,
            InventoryTransactionType::Waste
        );
    }

    // === ERROR RECOVERY ===

    #[test]
    fn test_error_recovery_invalid_transaction_type() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material = create_test_material(&service, "ERROR-RECOVERY-001", 50.0);

        // Try to create a transaction with invalid data
        // This test would require modifying the service to validate transaction data
        // For now, we'll test other error scenarios

        // Try to create a stock out transaction with insufficient stock
        let stock_out_invalid = CreateInventoryTransactionRequest {
            material_id: material.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 100.0, // More than available
            reference_number: Some("INVALID-TX"String::from("")),
            reference_type: Some("Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service
            .create_inventory_transaction(stock_out_invalid, Some("test_user".to_string()));
        assert!(result.is_err());
        assert!(result.is_err());

        let error = result.unwrap_err();
        match error {
            MaterialError::InsufficientStock(msg) => {
                assert!(msg.contains("Insufficient stock"));
            }
            _ => panic!("Expected InsufficientStock error"),
        }

        // Verify material stock wasn't changed
        let material_after = service
            .get_material_by_id(material.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material_after.current_stock, 50.0);
    }

    #[test]
    fn test_error_recovery_partial_transaction_rollback() {
        let test_db = TestDatabase::new();
        let service = MaterialService::new(test_db.db());

        let material1 = create_test_material(&service, "PARTIAL-RECOVERY-1", 100.0);
        let material2 = create_test_material(&service, "PARTIAL-RECOVERY-2", 50.0);

        // Create a successful transaction for material1
        let stock_out_success = CreateInventoryTransactionRequest {
            material_id: material1.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 25.0,
            reference_number: Some(String::from("SUCCESS-TX")),
            reference_type: Some(String::from("Order")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        service
            .create_inventory_transaction(stock_out_success, Some("test_user".to_string"))
            .unwrap();

        // Try to create a failed transaction for material2
        let stock_out_fail = CreateInventoryTransactionRequest {
            material_id: material2.id.clone().unwrap(),
            transaction_type: InventoryTransactionType::StockOut,
            quantity: 100.0, // More than available
            reference_number: Some("FAIL-TX"String::from("")),
            reference_type: Some("Order"String::from("")),
            notes: None,
            unit_cost: None,
            warehouse_id: None,
            location_from: None,
            location_to: None,
            batch_number: None,
            expiry_date: None,
            quality_status: None,
            intervention_id: None,
            step_id: None,
        };

        let result = service
            .create_inventory_transaction(stock_out_fail, Some("test_user".to_string()));
        assert!(result.is_err());
        assert!(result.is_err());

        // Verify material1's stock was updated (successful transaction)
        let material1_after = service
            .get_material_by_id(material1.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material1_after.current_stock, 75.0);

        // Verify material2's stock wasn't updated (failed transaction)
        let material2_after = service
            .get_material_by_id(material2.id.unwrap().as_str())
            .unwrap();
        assert_eq!(material2_after.current_stock, 50.0);
    }
}
