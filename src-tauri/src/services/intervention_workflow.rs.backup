//! Intervention Workflow Service - Handles PPF workflow operations
//!
//! This service manages the core PPF intervention workflow including:
//! - Starting interventions
//! - Advancing through workflow steps
//! - Saving step progress
//! - Finalizing interventions

use crate::db::Database;
use crate::db::{InterventionError, InterventionResult};
use crate::logging::{LogDomain, RPMARequestLogger};
use crate::models::common::TimestampString;
use crate::models::intervention::{Intervention, InterventionStatus};
use crate::models::step::{InterventionStep, StepStatus};
use crate::services::intervention_data::InterventionDataService;
use crate::services::intervention_types::*;

use std::sync::Arc;

/// Service for managing PPF intervention workflows
#[derive(Debug)]
pub struct InterventionWorkflowService {
    db: Arc<Database>,
    data: InterventionDataService,
}

impl InterventionWorkflowService {
    /// Create new workflow service
    pub fn new(db: Arc<Database>) -> Self {
        Self {
            data: InterventionDataService::new(db.clone()),
            db,
        }
    }

    /// Start a new PPF intervention
    pub fn start_intervention(
        &self,
        request: StartInterventionRequest,
        user_id: &str,
        correlation_id: &str,
    ) -> InterventionResult<StartInterventionResponse> {
        let logger = RPMARequestLogger::new(
            correlation_id.to_string(),
            Some(user_id.to_string()),
            LogDomain::Task,
        );
        let mut context = std::collections::HashMap::new();
        context.insert("task_id".to_string(), serde_json::json!(request.task_id));
        context.insert(
            "technician_id".to_string(),
            serde_json::json!(request.technician_id),
        );
        logger.info("Starting new PPF intervention", Some(context));

        // Basic validation - ensure required fields are present
        if request.task_id.is_empty() {
            logger.error("Task ID is required for intervention start", None, None);
            return Err(InterventionError::Validation(
                "Task ID is required".to_string(),
            ));
        }

        // Validate task_id format (allow both UUID and string formats for compatibility)
        if request.task_id.is_empty() {
            logger.error("Task ID cannot be empty", None, None);
            return Err(InterventionError::Validation(
                "Task ID cannot be empty".to_string(),
            ));
        }

        if request.technician_id.is_empty() {
            logger.error(
                "Technician ID is required for intervention start",
                None,
                None,
            );
            return Err(InterventionError::Validation(
                "Technician ID is required".to_string(),
            ));
        }

        // Attempt to start intervention with cleanup on failure
        match self.start_intervention_internal(&request, user_id, &logger) {
            Ok(response) => {
                let mut success_context = std::collections::HashMap::new();
                success_context.insert(
                    "intervention_id".to_string(),
                    serde_json::json!(response.intervention.id),
                );
                success_context.insert(
                    "step_count".to_string(),
                    serde_json::json!(response.steps.len()),
                );
                logger.info("Successfully started intervention", Some(success_context));
                Ok(response)
            }
            Err(e) => {
                // Cleanup on failure - attempt to rollback any partial state
                self.cleanup_failed_start(&request.task_id, &logger);
                let mut error_context = std::collections::HashMap::new();
                error_context.insert("task_id".to_string(), serde_json::json!(request.task_id));
                logger.error(
                    "Failed to start intervention",
                    Some(&e),
                    Some(error_context),
                );
                Err(e)
            }
        }
    }

    /// Internal start intervention logic (separated for error handling)
    fn start_intervention_internal(
        &self,
        request: &StartInterventionRequest,
        user_id: &str,
        logger: &RPMARequestLogger,
    ) -> InterventionResult<StartInterventionResponse> {
        // Execute all operations within a single transaction
        self.db
            .with_transaction(|tx| {
                // Create intervention record
                let intervention = self
                    .data
                    .create_intervention_with_tx(tx, request, user_id)
                    .map_err(|e| e.to_string())?;
                let mut create_context = std::collections::HashMap::new();
                create_context.insert(
                    "intervention_id".to_string(),
                    serde_json::json!(intervention.id),
                );
                logger.debug("Created intervention record", Some(create_context));

                // Initialize workflow steps
                let steps = self
                    .data
                    .initialize_workflow_steps_with_tx(tx, &intervention)
                    .map_err(|e| e.to_string())?;
                let mut steps_context = std::collections::HashMap::new();
                steps_context.insert("step_count".to_string(), serde_json::json!(steps.len()));
                logger.debug("Initialized workflow steps", Some(steps_context));

                // Link task to intervention with proper step ID validation
                let first_step_id = steps
                    .first()
                    .ok_or_else(|| "No workflow steps created".to_string())?
                    .id
                    .clone();

                self.data
                    .link_task_to_intervention_with_tx(
                        tx,
                        &request.task_id,
                        &intervention.id,
                        &first_step_id,
                    )
                    .map_err(|e| e.to_string())?;

                // Create response
                let response = StartInterventionResponse {
                    intervention,
                    steps,
                    initial_requirements: Vec::new(), // TODO: populate initial requirements
                };

                Ok(response)
            })
            .map_err(InterventionError::Database)
    }

    /// Cleanup partial state on failed intervention start
    fn cleanup_failed_start(&self, task_id: &str, logger: &RPMARequestLogger) {
        let mut cleanup_context = std::collections::HashMap::new();
        cleanup_context.insert("task_id".to_string(), serde_json::json!(task_id));
        logger.warn(
            "Cleaning up failed intervention start",
            Some(cleanup_context),
        );

        // Reset task workflow state if it was partially set
        if let Err(e) = self.db.get_connection().and_then(|conn| {
            conn.execute(
                "UPDATE tasks SET workflow_id = NULL, current_workflow_step_id = NULL, status = 'draft', started_at = NULL WHERE id = ? AND workflow_id IS NOT NULL",
                rusqlite::params![task_id]
            ).map_err(|db_err| db_err.to_string())
        }) {
            let mut cleanup_error_context = std::collections::HashMap::new();
            cleanup_error_context.insert("task_id".to_string(), serde_json::json!(task_id));
            cleanup_error_context.insert("error".to_string(), serde_json::json!(e));
            logger.error("Failed to cleanup task workflow state", None, Some(cleanup_error_context));
        }

        // Delete any orphaned intervention and steps for this task
        if let Err(e) = self.db.get_connection().and_then(|conn| {
            // Delete steps first
            conn.execute(
                "DELETE FROM intervention_steps WHERE intervention_id IN (SELECT id FROM interventions WHERE task_id = ?)",
                rusqlite::params![task_id]
            ).map_err(|db_err| db_err.to_string())?;
            // Delete intervention
            conn.execute(
                "DELETE FROM interventions WHERE task_id = ?",
                rusqlite::params![task_id]
            ).map_err(|db_err| db_err.to_string())
        }) {
            let mut cleanup_error_context = std::collections::HashMap::new();
            cleanup_error_context.insert("task_id".to_string(), serde_json::json!(task_id));
            cleanup_error_context.insert("error".to_string(), serde_json::json!(e));
            logger.error("Failed to cleanup orphaned intervention", None, Some(cleanup_error_context));
        } else {
            let mut success_context = std::collections::HashMap::new();
            success_context.insert("task_id".to_string(), serde_json::json!(task_id));
            logger.info("Successfully cleaned up orphaned intervention", Some(success_context));
        }
    }

    /// Validate that a step advancement is allowed based on current workflow state
    fn validate_step_advancement(
        &self,
        intervention: &Intervention,
        current_step: &InterventionStep,
        logger: &RPMARequestLogger,
    ) -> InterventionResult<()> {
        // Check intervention status
        if intervention.status != InterventionStatus::InProgress {
            let mut error_context = std::collections::HashMap::new();
            error_context.insert(
                "intervention_status".to_string(),
                serde_json::json!(intervention.status),
            );
            error_context.insert(
                "expected_status".to_string(),
                serde_json::json!("InProgress"),
            );
            logger.error(
                "Invalid intervention status for step advancement",
                None,
                Some(error_context),
            );
            return Err(InterventionError::Workflow(format!(
                "Intervention is not in progress (status: {:?})",
                intervention.status
            )));
        }

        // Check step status
        if current_step.step_status == StepStatus::Completed {
            let mut error_context = std::collections::HashMap::new();
            error_context.insert(
                "step_number".to_string(),
                serde_json::json!(current_step.step_number),
            );
            error_context.insert(
                "step_status".to_string(),
                serde_json::json!(current_step.step_status),
            );
            logger.error(
                "Attempted to advance already completed step",
                None,
                Some(error_context),
            );
            return Err(InterventionError::Workflow(format!(
                "Step {} is already completed",
                current_step.step_number
            )));
        }

        // Check step order - ensure previous steps are completed
        if current_step.step_number > 1 {
            let previous_step_number = current_step.step_number - 1;
            match self
                .data
                .get_step_by_number(&intervention.id, previous_step_number)
            {
                Ok(Some(prev_step)) => {
                    if prev_step.step_status != StepStatus::Completed {
                        let mut error_context = std::collections::HashMap::new();
                        error_context.insert(
                            "current_step".to_string(),
                            serde_json::json!(current_step.step_number),
                        );
                        error_context.insert(
                            "previous_step".to_string(),
                            serde_json::json!(previous_step_number),
                        );
                        error_context.insert(
                            "previous_status".to_string(),
                            serde_json::json!(prev_step.step_status),
                        );
                        logger.error(
                            "Attempted to advance step before completing previous step",
                            None,
                            Some(error_context),
                        );
                        return Err(InterventionError::Workflow(format!(
                            "Cannot advance to step {}: previous step {} is not completed (status: {:?})",
                            current_step.step_number, previous_step_number, prev_step.step_status
                        )));
                    }
                }
                Ok(None) => {
                    let mut error_context = std::collections::HashMap::new();
                    error_context.insert(
                        "intervention_id".to_string(),
                        serde_json::json!(intervention.id),
                    );
                    error_context.insert(
                        "expected_step".to_string(),
                        serde_json::json!(previous_step_number),
                    );
                    logger.error("Previous step not found", None, Some(error_context));
                    return Err(InterventionError::Workflow(format!(
                        "Previous step {} not found for intervention {}",
                        previous_step_number, intervention.id
                    )));
                }
                Err(e) => {
                    let mut error_context = std::collections::HashMap::new();
                    error_context.insert("error".to_string(), serde_json::json!(e.to_string()));
                    logger.error(
                        "Failed to validate previous step",
                        None,
                        Some(error_context),
                    );
                    return Err(InterventionError::Database(format!(
                        "Failed to validate step order: {}",
                        e
                    )));
                }
            }
        }

        // Check if intervention is locked or paused
        if intervention.status == InterventionStatus::Paused {
            let mut error_context = std::collections::HashMap::new();
            error_context.insert(
                "intervention_id".to_string(),
                serde_json::json!(intervention.id),
            );
            logger.error(
                "Attempted to advance step on paused intervention",
                None,
                Some(error_context),
            );
            return Err(InterventionError::Workflow(
                "Cannot advance steps on a paused intervention".to_string(),
            ));
        }

        Ok(())
    }

    /// Advance to the next step in the workflow
    pub async fn advance_step(
        &self,
        request: AdvanceStepRequest,
        correlation_id: &str,
        user_id: Option<&str>,
    ) -> InterventionResult<AdvanceStepResponse> {
        let logger = RPMARequestLogger::new(
            correlation_id.to_string(),
            user_id.map(|s| s.to_string()),
            LogDomain::Task,
        );
        let mut advance_context = std::collections::HashMap::new();
        advance_context.insert(
            "intervention_id".to_string(),
            serde_json::json!(request.intervention_id),
        );
        advance_context.insert("step_id".to_string(), serde_json::json!(request.step_id));
        logger.info("Advancing intervention step", Some(advance_context));

        // Get current intervention with retry logic
        let mut intervention = self
            .get_intervention_with_retry(&request.intervention_id, &logger)
            .await?;

        // Get current step with retry logic
        let mut current_step = self.get_step_with_retry(&request.step_id, &logger).await?;

        // Comprehensive workflow state validation
        self.validate_step_advancement(&intervention, &current_step, &logger)?;

        // Update step with collected data
        self.data
            .update_step_with_data(&mut current_step, &request)?;

        // Set step to in-progress if not already set
        if current_step.step_status == StepStatus::Pending {
            current_step.step_status = StepStatus::InProgress;
            current_step.started_at = TimestampString::now();
        }

        // Mark step as completed
        current_step.step_status = StepStatus::Completed;
        current_step.completed_at = TimestampString::now();

        // Save updated step with retry
        self.save_step_with_retry(&current_step, &logger).await?;

        // Update intervention progress
        self.data
            .update_intervention_progress(&mut intervention)
            .await
            .map_err(|e| {
                let mut progress_context = std::collections::HashMap::new();
                progress_context.insert(
                    "intervention_id".to_string(),
                    serde_json::json!(intervention.id),
                );
                logger.error(
                    "Failed to update intervention progress",
                    Some(&e),
                    Some(progress_context),
                );
                InterventionError::Database(format!("Failed to update progress: {}", e))
            })?;

        // Get next step if available
        let next_step = match self
            .data
            .get_next_step(&intervention, current_step.step_number)
        {
            Ok(step) => step,
            Err(_e) => {
                let mut next_step_context = std::collections::HashMap::new();
                next_step_context.insert(
                    "current_step".to_string(),
                    serde_json::json!(current_step.step_number),
                );
                logger.warn("Failed to get next step", Some(next_step_context));
                None // Continue without next step rather than failing
            }
        };

        // Calculate progress
        let progress_percentage = intervention.completion_percentage as f32;

        // Calculate completed requirements (simplified)
        let requirements_completed = vec![format!("step_{}_completed", current_step.step_number)];

        let mut completion_context = std::collections::HashMap::new();
        completion_context.insert(
            "progress_percentage".to_string(),
            serde_json::json!(progress_percentage),
        );
        completion_context.insert(
            "next_step".to_string(),
            serde_json::json!(next_step.as_ref().map(|s| s.step_number)),
        );
        logger.info("Step advancement completed", Some(completion_context));

        Ok(AdvanceStepResponse {
            step: current_step,
            next_step,
            progress_percentage,
            requirements_completed,
        })
    }

    /// Get intervention with retry logic
    async fn get_intervention_with_retry(
        &self,
        intervention_id: &str,
        logger: &RPMARequestLogger,
    ) -> InterventionResult<Intervention> {
        const MAX_RETRIES: u32 = 3;
        let mut attempt = 0;

        loop {
            match self.data.get_intervention(intervention_id) {
                Ok(Some(intervention)) => return Ok(intervention),
                Ok(None) => {
                    return Err(InterventionError::NotFound(format!(
                        "Intervention {} not found",
                        intervention_id
                    )));
                }
                Err(e) => {
                    attempt += 1;
                    if attempt >= MAX_RETRIES {
                        let mut retry_context = std::collections::HashMap::new();
                        retry_context.insert(
                            "intervention_id".to_string(),
                            serde_json::json!(intervention_id),
                        );
                        retry_context.insert("attempts".to_string(), serde_json::json!(attempt));
                        logger.error(
                            "Failed to get intervention after retries",
                            Some(&e),
                            Some(retry_context),
                        );
                        return Err(InterventionError::Database(format!(
                            "Failed to retrieve intervention after {} attempts: {}",
                            MAX_RETRIES, e
                        )));
                    }
                    let mut retry_warn_context = std::collections::HashMap::new();
                    retry_warn_context.insert(
                        "intervention_id".to_string(),
                        serde_json::json!(intervention_id),
                    );
                    retry_warn_context.insert("attempt".to_string(), serde_json::json!(attempt));
                    logger.warn(
                        "Failed to get intervention, retrying",
                        Some(retry_warn_context),
                    );
                    // Simple backoff - in production, use exponential backoff
                    std::thread::sleep(std::time::Duration::from_millis(100 * attempt as u64));
                }
            }
        }
    }

    /// Get step with retry logic
    async fn get_step_with_retry(
        &self,
        step_id: &str,
        logger: &RPMARequestLogger,
    ) -> InterventionResult<InterventionStep> {
        const MAX_RETRIES: u32 = 3;
        let mut attempt = 0;

        loop {
            match self.data.get_step(step_id) {
                Ok(Some(step)) => return Ok(step),
                Ok(None) => {
                    return Err(InterventionError::NotFound(format!(
                        "Step {} not found",
                        step_id
                    )));
                }
                Err(e) => {
                    attempt += 1;
                    if attempt >= MAX_RETRIES {
                        let mut step_retry_context = std::collections::HashMap::new();
                        step_retry_context
                            .insert("step_id".to_string(), serde_json::json!(step_id));
                        step_retry_context
                            .insert("attempts".to_string(), serde_json::json!(attempt));
                        logger.error(
                            "Failed to get step after retries",
                            Some(&e),
                            Some(step_retry_context),
                        );
                        return Err(InterventionError::Database(format!(
                            "Failed to retrieve step after {} attempts: {}",
                            MAX_RETRIES, e
                        )));
                    }
                    let mut step_retry_warn_context = std::collections::HashMap::new();
                    step_retry_warn_context
                        .insert("step_id".to_string(), serde_json::json!(step_id));
                    step_retry_warn_context
                        .insert("attempt".to_string(), serde_json::json!(attempt));
                    logger.warn(
                        "Failed to get step, retrying",
                        Some(step_retry_warn_context),
                    );
                    std::thread::sleep(std::time::Duration::from_millis(100 * attempt as u64));
                }
            }
        }
    }

    /// Save step with retry logic
    async fn save_step_with_retry(
        &self,
        step: &InterventionStep,
        logger: &RPMARequestLogger,
    ) -> InterventionResult<()> {
        const MAX_RETRIES: u32 = 3;
        let mut attempt = 0;

        loop {
            match self.data.save_step(step) {
                Ok(()) => return Ok(()),
                Err(e) => {
                    attempt += 1;
                    if attempt >= MAX_RETRIES {
                        let mut save_retry_context = std::collections::HashMap::new();
                        save_retry_context
                            .insert("step_id".to_string(), serde_json::json!(step.id));
                        save_retry_context
                            .insert("attempts".to_string(), serde_json::json!(attempt));
                        logger.error(
                            "Failed to save step after retries",
                            Some(&e),
                            Some(save_retry_context),
                        );
                        return Err(InterventionError::Database(format!(
                            "Failed to save step after {} attempts: {}",
                            MAX_RETRIES, e
                        )));
                    }
                    let mut save_retry_warn_context = std::collections::HashMap::new();
                    save_retry_warn_context
                        .insert("step_id".to_string(), serde_json::json!(step.id));
                    save_retry_warn_context
                        .insert("attempt".to_string(), serde_json::json!(attempt));
                    logger.warn(
                        "Failed to save step, retrying",
                        Some(save_retry_warn_context),
                    );
                    std::thread::sleep(std::time::Duration::from_millis(100 * attempt as u64));
                }
            }
        }
    }

    /// Save step progress without advancing to next step
    pub async fn save_step_progress(
        &self,
        request: SaveStepProgressRequest,
        correlation_id: &str,
        user_id: Option<&str>,
    ) -> InterventionResult<InterventionStep> {
        let logger = RPMARequestLogger::new(
            correlation_id.to_string(),
            user_id.map(|s| s.to_string()),
            LogDomain::Task,
        );
        logger.info("Saving step progress", None);

        // Log request details for debugging
        eprintln!("[DEBUG] SaveStepProgressRequest: step_id={}, collected_data={:?}, notes={:?}, photos_count={:?}",
            request.step_id, request.collected_data, request.notes,
            request.photos.as_ref().map(|p| p.len()).unwrap_or(0));

        // Get current step
        eprintln!(
            "[DEBUG] Attempting to get step with ID: {}",
            request.step_id
        );
        let mut step = self
            .data
            .get_step(&request.step_id)
            .map_err(|e| {
                eprintln!("[DEBUG] Database error getting step: {:?}", e);
                e
            })?
            .ok_or_else(|| {
                eprintln!("[DEBUG] Step not found with ID: {}", request.step_id);
                InterventionError::NotFound(format!("Step {} not found", request.step_id))
            })?;

        // Log step details before updating
        eprintln!(
            "[DEBUG] Found step: id={}, intervention_id={}, step_number={}, step_status={:?}",
            step.id, step.intervention_id, step.step_number, step.step_status
        );

        // Set step to in-progress if not already set
        if step.step_status == StepStatus::Pending {
            step.step_status = StepStatus::InProgress;
            step.started_at = TimestampString::now();
        }

        // Update step with collected data (similar to advance_step but without marking as completed)
        step.collected_data = Some(request.collected_data.clone());
        step.notes = request.notes.clone();

        if let Some(photos) = &request.photos {
            step.photo_count = photos.len() as i32;
            step.photo_urls = Some(photos.clone());
        }

        // Validate that the data can be serialized for database storage
        if let Err(e) = serde_json::to_string(&step.collected_data) {
            eprintln!("[DEBUG] Failed to serialize collected_data: {:?}", e);
            return Err(InterventionError::Validation(format!(
                "Invalid collected_data format: {}",
                e
            )));
        }

        // Save the step
        self.data.save_step(&step).map_err(|e| {
            eprintln!("[DEBUG] Failed to save step in database: {:?}", e);
            e
        })?;

        logger.debug("Successfully saved progress for step", None);

        Ok(step)
    }

    /// Validate that an intervention can be finalized
    fn validate_intervention_finalization(
        &self,
        intervention: &Intervention,
        logger: &RPMARequestLogger,
    ) -> InterventionResult<()> {
        // Check intervention status
        if intervention.status == InterventionStatus::Completed {
            let mut error_context = std::collections::HashMap::new();
            error_context.insert(
                "intervention_id".to_string(),
                serde_json::json!(intervention.id),
            );
            error_context.insert("status".to_string(), serde_json::json!(intervention.status));
            logger.error(
                "Attempted to finalize already completed intervention",
                None,
                Some(error_context),
            );
            return Err(InterventionError::Workflow(
                "Intervention is already completed".to_string(),
            ));
        }

        if intervention.status != InterventionStatus::InProgress {
            let mut error_context = std::collections::HashMap::new();
            error_context.insert(
                "intervention_id".to_string(),
                serde_json::json!(intervention.id),
            );
            error_context.insert("status".to_string(), serde_json::json!(intervention.status));
            logger.error(
                "Attempted to finalize intervention not in progress",
                None,
                Some(error_context),
            );
            return Err(InterventionError::Workflow(format!(
                "Cannot finalize intervention with status {:?}",
                intervention.status
            )));
        }

        // Check that all mandatory steps are completed
        let steps = self
            .data
            .get_intervention_steps(&intervention.id)
            .map_err(|e| {
                InterventionError::Database(format!("Failed to get steps for validation: {}", e))
            })?;

        let mandatory_steps = steps.iter().filter(|s| s.is_mandatory).collect::<Vec<_>>();
        let completed_mandatory_steps = mandatory_steps
            .iter()
            .filter(|s| s.step_status == StepStatus::Completed)
            .collect::<Vec<_>>();

        if mandatory_steps.len() != completed_mandatory_steps.len() {
            let incomplete_steps: Vec<i32> = mandatory_steps
                .iter()
                .filter(|s| s.step_status != StepStatus::Completed)
                .map(|s| s.step_number)
                .collect();

            let mut error_context = std::collections::HashMap::new();
            error_context.insert(
                "intervention_id".to_string(),
                serde_json::json!(intervention.id),
            );
            error_context.insert(
                "incomplete_steps".to_string(),
                serde_json::json!(incomplete_steps),
            );
            error_context.insert(
                "total_mandatory".to_string(),
                serde_json::json!(mandatory_steps.len()),
            );
            error_context.insert(
                "completed_mandatory".to_string(),
                serde_json::json!(completed_mandatory_steps.len()),
            );
            logger.error(
                "Attempted to finalize intervention with incomplete mandatory steps",
                None,
                Some(error_context),
            );

            return Err(InterventionError::Workflow(format!(
                "Cannot finalize intervention: {} mandatory steps incomplete: {:?}",
                incomplete_steps.len(),
                incomplete_steps
            )));
        }

        // Note: Photos are now optional and can be added later even after intervention completion
        // No validation required for photo counts during finalization

        Ok(())
    }

    /// Finalize an intervention
    pub fn finalize_intervention(
        &self,
        request: FinalizeInterventionRequest,
        correlation_id: &str,
        user_id: Option<&str>,
    ) -> InterventionResult<FinalizeInterventionResponse> {
        let logger = RPMARequestLogger::new(
            correlation_id.to_string(),
            user_id.map(|s| s.to_string()),
            LogDomain::Task,
        );
        logger.info("Finalizing intervention", None);
        // Get intervention
        let mut intervention = self
            .data
            .get_intervention(&request.intervention_id)?
            .ok_or_else(|| {
                InterventionError::NotFound(format!(
                    "Intervention {} not found",
                    request.intervention_id
                ))
            })?;

        // Comprehensive finalization validation
        self.validate_intervention_finalization(&intervention, &logger)?;

        // Save collected data and photos to the finalization step if provided
        let steps = self.data.get_intervention_steps(&intervention.id)?;
        if let Some(finalization_step) = steps
            .iter()
            .find(|s| s.step_type == crate::models::step::StepType::Finalization)
        {
            let mut updated_step = finalization_step.clone();
            let mut step_updated = false;

            if let Some(collected_data) = &request.collected_data {
                updated_step.collected_data = Some(collected_data.clone());
                step_updated = true;
            }

            if let Some(photos) = &request.photos {
                updated_step.photo_count = photos.len() as i32;
                updated_step.photo_urls = Some(photos.clone());
                step_updated = true;
            }

            if step_updated {
                updated_step.step_status = StepStatus::Completed;
                updated_step.completed_at = TimestampString(Some(crate::models::common::now()));
                self.data.save_step(&updated_step)?;
                logger.debug(
                    "Updated finalization step with collected data and/or photos",
                    None,
                );
            }
        }

        // Update final data
        intervention.customer_satisfaction = request.customer_satisfaction;
        intervention.quality_score = request.quality_score;
        intervention.final_observations = request.final_observations;
        intervention.customer_signature = request.customer_signature;
        intervention.customer_comments = request.customer_comments;
        intervention.status = InterventionStatus::Completed;
        intervention.completed_at = TimestampString(Some(crate::models::common::now()));
        intervention.updated_at = crate::models::common::now();

        // Calculate actual duration
        if let (Some(start), Some(end)) = (
            intervention.started_at.inner(),
            intervention.completed_at.inner(),
        ) {
            intervention.actual_duration = Some(((end - start) / 60000) as i32);
        }

        // Save intervention
        self.data.save_intervention(&intervention)?;

        // Update associated task status to completed
        let now = crate::models::common::now();
        self.db.get_connection()?.execute(
            "UPDATE tasks SET status = 'completed', completed_at = ?, updated_at = ? WHERE id = ?",
            rusqlite::params![now, now, intervention.task_id],
        ).map_err(|e| InterventionError::Database(format!("Failed to update task status: {}", e)))?;

        // Calculate basic metrics
        let metrics = crate::services::intervention_types::InterventionMetrics {
            total_duration_minutes: intervention.actual_duration.unwrap_or(0),
            completion_rate: 100.0, // Fully completed
            quality_score: intervention.quality_score,
            customer_satisfaction: intervention.customer_satisfaction,
            steps_completed: intervention.current_step,
            total_steps: intervention.current_step, // Assuming all steps up to current are completed
            photos_taken: 0,                        // Would need to count from steps
        };

        logger.info("Intervention finalized successfully", None);

        Ok(FinalizeInterventionResponse {
            intervention,
            metrics,
        })
    }
}
