use crate::db::FromSqlRow;
use rusqlite::Row;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
// Conditional import removed
use ts_rs::TS;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[derive(TS)]
#[serde(rename_all = "camelCase")]
pub struct CalendarEvent {
    pub id: String,
    pub title: String,
    pub description: Option<String>,

    // Temporal
    pub start_datetime: String, // ISO 8601
    pub end_datetime: String,
    pub all_day: bool,
    pub timezone: String,

    // Type and category
    pub event_type: EventType,
    pub category: Option<String>,

    // Relations
    pub task_id: Option<String>,
    pub client_id: Option<String>,
    pub technician_id: Option<String>,

    // Meeting details
    pub location: Option<String>,
    pub meeting_link: Option<String>,
    pub is_virtual: bool,

    // Participants
    pub participants: Vec<EventParticipant>,

    // Recurrence
    pub is_recurring: bool,
    pub recurrence_rule: Option<String>,
    pub parent_event_id: Option<String>,

    // Reminders
    pub reminders: Vec<i32>, // Minutes before event

    // Status and metadata
    pub status: EventStatus,
    pub color: Option<String>,
    pub tags: Vec<String>,
    pub notes: Option<String>,

    // Sync and audit
    pub synced: bool,
    pub last_synced_at: Option<i64>,
    pub created_at: i64,
    pub updated_at: i64,
    pub created_by: Option<String>,
    pub updated_by: Option<String>,
    pub deleted_at: Option<i64>,
    pub deleted_by: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[derive(TS)]
#[serde(rename_all = "lowercase")]
pub enum EventType {
    Meeting,
    Appointment,
    Task,
    Reminder,
    Other,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[derive(TS)]
#[serde(rename_all = "lowercase")]
pub enum EventStatus {
    Confirmed,
    Tentative,
    Cancelled,
}

impl FromStr for EventType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "meeting" => Ok(EventType::Meeting),
            "appointment" => Ok(EventType::Appointment),
            "task" => Ok(EventType::Task),
            "reminder" => Ok(EventType::Reminder),
            "other" => Ok(EventType::Other),
            _ => Err(format!("Unknown event type: {}", s)),
        }
    }
}

impl FromStr for EventStatus {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(EventStatus::Confirmed),
            "tentative" => Ok(EventStatus::Tentative),
            "cancelled" => Ok(EventStatus::Cancelled),
            _ => Err(format!("Unknown event status: {}", s)),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[derive(TS)]
#[serde(rename_all = "camelCase")]
pub struct EventParticipant {
    pub id: String,
    pub name: String,
    pub email: Option<String>,
    pub status: ParticipantStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[derive(TS)]
#[serde(rename_all = "lowercase")]
pub enum ParticipantStatus {
    Accepted,
    Declined,
    Tentative,
    NeedsAction,
}

#[derive(Debug, Clone, Deserialize)]
#[cfg_attr(feature = "ts-rs", derive(TS))]
#[serde(rename_all = "camelCase")]
pub struct CreateEventInput {
    pub title: String,
    pub description: Option<String>,
    pub start_datetime: String,
    pub end_datetime: String,
    pub all_day: Option<bool>,
    pub timezone: Option<String>,
    pub event_type: Option<EventType>,
    pub category: Option<String>,
    pub task_id: Option<String>,
    pub client_id: Option<String>,
    pub technician_id: Option<String>,
    pub location: Option<String>,
    pub meeting_link: Option<String>,
    pub is_virtual: Option<bool>,
    pub participants: Option<Vec<EventParticipant>>,
    pub reminders: Option<Vec<i32>>,
    pub color: Option<String>,
    pub tags: Option<Vec<String>>,
    pub notes: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
#[cfg_attr(feature = "ts-rs", derive(TS))]
#[serde(rename_all = "camelCase")]
pub struct UpdateEventInput {
    pub title: Option<String>,
    pub description: Option<String>,
    pub start_datetime: Option<String>,
    pub end_datetime: Option<String>,
    pub all_day: Option<bool>,
    pub timezone: Option<String>,
    pub event_type: Option<EventType>,
    pub category: Option<String>,
    pub task_id: Option<String>,
    pub client_id: Option<String>,
    pub location: Option<String>,
    pub meeting_link: Option<String>,
    pub is_virtual: Option<bool>,
    pub participants: Option<Vec<EventParticipant>>,
    pub status: Option<EventStatus>,
    pub reminders: Option<Vec<i32>>,
    pub color: Option<String>,
    pub tags: Option<Vec<String>>,
    pub notes: Option<String>,
}

/// Conversion implementations for database operations
impl FromSqlRow for CalendarEvent {
    fn from_row(row: &Row) -> Result<Self, rusqlite::Error> {
        Ok(CalendarEvent {
            id: row.get(0)?,
            title: row.get(1)?,
            description: row.get(2)?,
            start_datetime: row.get(3)?,
            end_datetime: row.get(4)?,
            all_day: row.get::<_, i32>(5)? != 0,
            timezone: row.get(6)?,
            event_type: row
                .get::<_, String>(7)?
                .parse::<EventType>()
                .unwrap_or(EventType::Meeting),
            category: row.get(8)?,
            task_id: row.get(9)?,
            client_id: row.get(10)?,
            technician_id: row.get(11)?,
            location: row.get(12)?,
            meeting_link: row.get(13)?,
            is_virtual: row.get::<_, i32>(14)? != 0,
            participants: row
                .get::<_, Option<String>>(15)?
                .and_then(|s| serde_json::from_str(&s).ok())
                .unwrap_or_default(),
            is_recurring: row.get::<_, i32>(16)? != 0,
            recurrence_rule: row.get(17)?,
            parent_event_id: row.get(18)?,
            reminders: row
                .get::<_, Option<String>>(19)?
                .and_then(|s| serde_json::from_str(&s).ok())
                .unwrap_or_default(),
            status: row
                .get::<_, String>(20)?
                .parse::<EventStatus>()
                .unwrap_or(EventStatus::Confirmed),
            color: row.get(21)?,
            tags: row
                .get::<_, Option<String>>(22)?
                .and_then(|s| serde_json::from_str(&s).ok())
                .unwrap_or_default(),
            notes: row.get(23)?,
            synced: row.get::<_, i32>(24)? != 0,
            last_synced_at: row.get(25)?,
            created_at: row.get(26)?,
            updated_at: row.get(27)?,
            created_by: row.get(28)?,
            updated_by: row.get(29)?,
            deleted_at: row.get(30)?,
            deleted_by: row.get(31)?,
        })
    }
}
