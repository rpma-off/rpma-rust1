//! Photo model

use super::common::*;
use crate::db::FromSqlRow;
use rusqlite::{Result as SqliteResult, Row, ToSql};
use serde::{Deserialize, Serialize};
// Conditional import removed
use ts_rs::TS;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[derive(TS)]
#[serde(rename_all = "lowercase")]
pub enum PhotoType {
    Before,
    During,
    After,
}

impl std::fmt::Display for PhotoType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            Self::Before => "before",
            Self::During => "during",
            Self::After => "after",
        };
        write!(f, "{}", s)
    }
}

impl ToSql for PhotoType {
    fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
        Ok(rusqlite::types::ToSqlOutput::Owned(self.to_string().into()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[derive(TS)]
#[serde(rename_all = "snake_case")]
pub enum PhotoCategory {
    VehicleCondition,
    Workspace,
    StepProgress,
    QcCheck,
    FinalResult,
    Other,
}

impl std::fmt::Display for PhotoCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            Self::VehicleCondition => "vehicle_condition",
            Self::Workspace => "workspace",
            Self::StepProgress => "step_progress",
            Self::QcCheck => "qc_check",
            Self::FinalResult => "final_result",
            Self::Other => "other",
        };
        write!(f, "{}", s)
    }
}

impl ToSql for PhotoCategory {
    fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
        Ok(rusqlite::types::ToSqlOutput::Owned(self.to_string().into()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[derive(TS)]
pub struct Photo {
    pub id: String,
    pub intervention_id: String,
    pub step_id: Option<String>,
    pub step_number: Option<i32>,

    pub file_path: String,
    pub file_name: Option<String>,
    pub file_size: Option<i64>,
    pub mime_type: String,
    pub width: Option<i32>,
    pub height: Option<i32>,

    pub photo_type: Option<PhotoType>,
    pub photo_category: Option<PhotoCategory>,
    pub photo_angle: Option<String>,
    pub zone: Option<String>,

    pub title: Option<String>,
    pub description: Option<String>,
    pub notes: Option<String>,
    #[cfg_attr(any(feature = "specta", feature = "ts-rs"), ts(type = "any"))]
    pub annotations: Option<serde_json::Value>,

    // GPS location - separate fields to match database schema
    pub gps_location_lat: Option<f64>,
    pub gps_location_lon: Option<f64>,
    pub gps_location_accuracy: Option<f64>,

    pub quality_score: Option<i32>,
    pub blur_score: Option<i32>,
    pub exposure_score: Option<i32>,
    pub composition_score: Option<i32>,

    pub is_required: bool,
    pub is_approved: bool,
    pub approved_by: Option<String>,
    #[serde(serialize_with = "serialize_optional_timestamp")]
    pub approved_at: Option<i64>,
    pub rejection_reason: Option<String>,
    pub synced: bool,
    pub storage_url: Option<String>,
    pub upload_retry_count: i32,
    pub upload_error: Option<String>,
    #[serde(serialize_with = "serialize_optional_timestamp")]
    pub last_synced_at: Option<i64>,
    #[serde(serialize_with = "serialize_optional_timestamp")]
    pub captured_at: Option<i64>,
    #[serde(serialize_with = "serialize_optional_timestamp")]
    #[cfg_attr(feature = "ts-rs", ts(type = "string | null"))]
    pub uploaded_at: Option<i64>,
    #[serde(serialize_with = "serialize_timestamp")]
    #[cfg_attr(feature = "ts-rs", ts(type = "string"))]
    pub created_at: i64,
    #[serde(serialize_with = "serialize_timestamp")]
    #[cfg_attr(feature = "ts-rs", ts(type = "string"))]
    pub updated_at: i64,
}

impl Photo {
    pub fn new(intervention_id: String, file_path: String) -> Self {
        let now = now();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            intervention_id,
            step_id: None,
            step_number: None,
            file_path,
            file_name: None,
            file_size: None,
            mime_type: "image/jpeg".to_string(),
            width: None,
            height: None,
            photo_type: None,
            photo_category: None,
            photo_angle: None,
            zone: None,
            title: None,
            description: None,
            notes: None,
            annotations: None,
            gps_location_lat: None,
            gps_location_lon: None,
            gps_location_accuracy: None,
            quality_score: None,
            blur_score: None,
            exposure_score: None,
            composition_score: None,
            is_required: false,
            is_approved: true,
            approved_by: None,
            approved_at: None,
            rejection_reason: None,
            synced: false,
            storage_url: None,
            upload_retry_count: 0,
            upload_error: None,
            last_synced_at: None,
            captured_at: Some(now),
            uploaded_at: None,
            created_at: now,
            updated_at: now,
        }
    }

    pub fn from_row(row: &Row) -> SqliteResult<Self> {
        let gps_location_lat: Option<f64> = row.get("gps_location_lat")?;
        let gps_location_lon: Option<f64> = row.get("gps_location_lon")?;
        let gps_location_accuracy: Option<f64> = row.get("gps_location_accuracy")?;

        Ok(Self {
            id: row.get("id")?,
            intervention_id: row.get("intervention_id")?,
            step_id: row.get("step_id")?,
            step_number: row.get("step_number")?,

            file_path: row.get("file_path")?,
            file_name: row.get("file_name")?,
            file_size: row.get("file_size")?,
            mime_type: row.get("mime_type")?,
            width: row.get("width")?,
            height: row.get("height")?,

            photo_type: row
                .get::<_, Option<String>>("photo_type")?
                .and_then(|s| serde_json::from_str(&format!(r#""{}""#, s)).ok()),
            photo_category: row
                .get::<_, Option<String>>("photo_category")?
                .and_then(|s| serde_json::from_str(&format!(r#""{}""#, s)).ok()),
            photo_angle: row.get("photo_angle")?,
            zone: row.get("zone")?,

            title: row.get("title")?,
            description: row.get("description")?,
            notes: row.get("notes")?,
            annotations: row
                .get::<_, Option<String>>("annotations")?
                .and_then(|s| serde_json::from_str(&s).ok()),

            gps_location_lat,
            gps_location_lon,
            gps_location_accuracy,

            quality_score: row.get("quality_score")?,
            blur_score: row.get("blur_score")?,
            exposure_score: row.get("exposure_score")?,
            composition_score: row.get("composition_score")?,

            is_required: row.get::<_, i32>("is_required")? == 1,
            is_approved: row.get::<_, i32>("is_approved")? == 1,
            approved_by: row.get("approved_by")?,
            approved_at: row.get("approved_at")?,
            rejection_reason: row.get("rejection_reason")?,
            synced: row.get::<_, i32>("synced")? == 1,
            storage_url: row.get("storage_url")?,
            upload_retry_count: row.get("upload_retry_count")?,
            upload_error: row.get("upload_error")?,
            last_synced_at: row.get("last_synced_at")?,
            captured_at: row.get("captured_at")?,
            uploaded_at: row.get("uploaded_at")?,
            created_at: row.get("created_at")?,
            updated_at: row.get("updated_at")?,
        })
    }
}

impl FromSqlRow for Photo {
    fn from_row(row: &Row) -> SqliteResult<Self> {
        Self::from_row(row)
    }
}
